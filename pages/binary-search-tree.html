<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Binary search tree — Visualization</title>
  <link rel="stylesheet" href="../css/common.css">
  <style>
    .tree-wrap {
      padding: 1.5rem;
      background: #1e2130;
      border-radius: 12px;
      min-height: 280px;
      overflow: auto;
      border: 1px solid #3b4261;
    }
    .tree-wrap svg {
      display: block;
      margin: 0 auto;
    }
    .tree-edge {
      fill: none;
      stroke: #89b4fa;
      stroke-width: 2;
      stroke-linecap: round;
    }
    .tree-node {
      fill: #3d4458;
      stroke: #89b4fa;
      stroke-width: 1.5;
      transition: stroke 0.2s, filter 0.2s, fill 0.2s;
    }
    .tree-node.current {
      stroke: #7dcfff;
      fill: #3b4261;
      filter: drop-shadow(0 0 8px rgba(125, 207, 255, 0.5));
    }
    .tree-node.new {
      stroke: #9ece6a;
      fill: #2d3d2d;
      filter: drop-shadow(0 0 6px rgba(158, 206, 106, 0.5));
    }
    .tree-node-text {
      fill: #e4e8f0;
      font-family: 'Segoe UI', system-ui, sans-serif;
      font-weight: 600;
      font-size: 13px;
      text-anchor: middle;
      dominant-baseline: central;
    }
    .tree-node.current .tree-node-text { fill: #7dcfff; }
    .tree-node.new .tree-node-text { fill: #9ece6a; }
  </style>
</head>
<body>
  <h1>Binary search tree</h1>
  <p class="subtitle">Step-by-step: current node highlighted and pseudocode shown for each step.</p>
  <div class="controls">
    <input type="text" id="val" placeholder="Value" style="width:80px">
    <button onclick="insert()">Insert</button>
    <button onclick="search()">Search</button>
    <button class="danger" id="btnClear" onclick="clearTree()">Clear</button>
  </div>
  <div class="controls">
    <span class="playback-label">Size:</span>
    <input type="number" id="rndSize" min="1" max="15" value="7" style="width:50px">
    <span class="playback-label">Shape:</span>
    <label><input type="radio" name="treeShape" id="shapeUnbalanced" checked> Unbalanced</label>
    <label><input type="radio" name="treeShape" id="shapeBalanced"> Balanced</label>
    <button onclick="randomTree()">Generate</button>
  </div>
  <div class="controls playback-row">
    <span class="playback-label">Playback:</span>
    <label><input type="radio" name="playback" id="modeAutoplay" checked> Autoplay</label>
    <label><input type="radio" name="playback" id="modeStep"> Step by step</label>
    <button type="button" id="btnNextStep" disabled>Next step</button>
  </div>
  <div id="log">Operations and pseudocode appear here.</div>
  <div class="tree-wrap" id="tree"></div>

  <script>
    let root = null;
    const STEP = 1100;
    let animating = false;
    function getAutoplay() { return document.getElementById('modeAutoplay').checked; }
    function setBtns(on) { animating = !on; document.querySelectorAll('.controls button:not(#btnClear):not(#btnNextStep)').forEach(b => { b.disabled = !on; }); const nb = document.getElementById('btnNextStep'); if (nb) nb.disabled = on || getAutoplay(); }
    function waitForStep() { return new Promise(r => { window._resolveStep = r; }); }
    function step() { return getAutoplay() ? new Promise(r => setTimeout(r, STEP)) : waitForStep(); }
    function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }
    document.getElementById('modeAutoplay').addEventListener('change', function() { if (document.getElementById('btnNextStep')) document.getElementById('btnNextStep').disabled = true; });
    document.getElementById('modeStep').addEventListener('change', function() { if (animating) document.getElementById('btnNextStep').disabled = false; });
    document.getElementById('btnNextStep').addEventListener('click', function() { if (window._resolveStep) { window._resolveStep(); window._resolveStep = null; } });
    function esc(s) { return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }
    function showPseudo(lines, active, msg) {
      document.getElementById('log').innerHTML = (lines && lines.length ? lines.map((l,i) => '<span class="pseudo-line' + (i===active?' active':'') + '">' + esc(l) + '</span>').join('') : '') + (msg ? '<span class="message">' + esc(msg) + '</span>' : '');
    }
    function treeHeight(n) { if (!n) return 0; return 1 + Math.max(treeHeight(n.left), treeHeight(n.right)); }
    const NODE_R = 22;
    const LEVEL_DY = 72;
    const PAD = 40;
    function assignCoords(n, left, right, y, coords) {
      if (!n) return;
      const x = (left + right) / 2;
      n._x = x;
      n._y = y;
      coords.push(n);
      const half = (right - left) / 2;
      assignCoords(n.left, left, left + half, y + LEVEL_DY, coords);
      assignCoords(n.right, left + half, right, y + LEVEL_DY, coords);
    }
    function render(highlightVal = null, newVal = null) {
      const el = document.getElementById('tree');
      el.innerHTML = '';
      if (!root) { el.innerHTML = '<p style="color:#565f89;margin:0;">(empty tree)</p>'; return; }
      const h = treeHeight(root);
      const width = Math.max(320, Math.pow(2, h) * 48);
      const totalWidth = width + PAD * 2;
      const totalHeight = h * LEVEL_DY + PAD * 2;
      const coords = [];
      assignCoords(root, PAD, PAD + width, PAD, coords);
      const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
      svg.setAttribute('viewBox', '0 0 ' + totalWidth + ' ' + totalHeight);
      svg.setAttribute('width', '100%');
      svg.setAttribute('height', '' + totalHeight);
      var defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
      var marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
      marker.setAttribute('id', 'bst-arrow');
      marker.setAttribute('markerWidth', '8');
      marker.setAttribute('markerHeight', '6');
      marker.setAttribute('refX', '7');
      marker.setAttribute('refY', '3');
      marker.setAttribute('orient', 'auto');
      var poly = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
      poly.setAttribute('points', '0 0, 8 3, 0 6');
      poly.setAttribute('fill', '#89b4fa');
      marker.appendChild(poly);
      defs.appendChild(marker);
      svg.appendChild(defs);
      function edgeEnd(px, py, cx, cy) {
        const dx = cx - px, dy = cy - py;
        const len = Math.sqrt(dx * dx + dy * dy) || 1;
        return { x: cx - (dx / len) * NODE_R, y: cy - (dy / len) * NODE_R };
      }
      function edgeStart(px, py, cx, cy) {
        const dx = cx - px, dy = cy - py;
        const len = Math.sqrt(dx * dx + dy * dy) || 1;
        return { x: px + (dx / len) * NODE_R, y: py + (dy / len) * NODE_R };
      }
      coords.forEach(function (n) {
        if (n.left) {
          const start = edgeStart(n._x, n._y, n.left._x, n.left._y);
          const end = edgeEnd(n._x, n._y, n.left._x, n.left._y);
          const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
          line.setAttribute('x1', start.x);
          line.setAttribute('y1', start.y);
          line.setAttribute('x2', end.x);
          line.setAttribute('y2', end.y);
          line.setAttribute('class', 'tree-edge');
          line.setAttribute('stroke', '#89b4fa');
          line.setAttribute('stroke-width', '2');
          line.setAttribute('marker-end', 'url(#bst-arrow)');
          svg.appendChild(line);
        }
        if (n.right) {
          const start = edgeStart(n._x, n._y, n.right._x, n.right._y);
          const end = edgeEnd(n._x, n._y, n.right._x, n.right._y);
          const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
          line.setAttribute('x1', start.x);
          line.setAttribute('y1', start.y);
          line.setAttribute('x2', end.x);
          line.setAttribute('y2', end.y);
          line.setAttribute('class', 'tree-edge');
          line.setAttribute('stroke', '#89b4fa');
          line.setAttribute('stroke-width', '2');
          line.setAttribute('marker-end', 'url(#bst-arrow)');
          svg.appendChild(line);
        }
      });
      coords.forEach(function (n) {
        const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        g.setAttribute('class', 'tree-node' + (highlightVal !== null && n.value === highlightVal ? ' current' : '') + (newVal !== null && n.value === newVal ? ' new' : ''));
        const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        circle.setAttribute('cx', n._x);
        circle.setAttribute('cy', n._y);
        circle.setAttribute('r', NODE_R);
        circle.setAttribute('fill', '#3d4458');
        circle.setAttribute('stroke', '#89b4fa');
        circle.setAttribute('stroke-width', '1.5');
        g.appendChild(circle);
        const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        text.setAttribute('x', n._x);
        text.setAttribute('y', n._y);
        text.setAttribute('class', 'tree-node-text');
        text.setAttribute('fill', '#e4e8f0');
        text.textContent = n.value;
        g.appendChild(text);
        svg.appendChild(g);
      });
      el.appendChild(svg);
    }
    const P_INSERT = [
      '// Insert — find place by BST order: left < node < right',
      'if root is null: root = new Node(value); return',
      'current = root',
      'while true:',
      '  if value < current.value: go left',
      '  else if value > current.value: go right',
      '  else: duplicate — return',
      '  if child is null: insert new node there; return'
    ];
    async function insert() {
      const val = document.getElementById('val').value.trim();
      if (!val) { showPseudo([], -1, 'Enter a value.'); return; }
      const v = Number(val);
      if (isNaN(v)) { showPseudo([], -1, 'Enter a number.'); return; }
      document.getElementById('val').value = '';
      setBtns(false);
      if (!root) {
        showPseudo(P_INSERT, 0, 'Root is null → create root ' + v + '.');
        showPseudo(P_INSERT, 1, 'root = new Node(' + v + '); return'); await step();
        root = { value: v, left: null, right: null };
        render(null, v);
        setBtns(true);
        return;
      }
      let cur = root;
      showPseudo(P_INSERT, 2, 'current = root. Value ' + cur.value + '.'); render(cur.value);
      await step();
      while (true) {
        showPseudo(P_INSERT, 3, 'while: compare ' + v + ' with ' + cur.value); render(cur.value);
        await step();
        if (v < cur.value) {
          showPseudo(P_INSERT, 4, v + ' < ' + cur.value + ' → go left.');
          await step();
          if (!cur.left) {
            showPseudo(P_INSERT, 7, 'Left is null → insert new node here.'); render(cur.value);
            cur.left = { value: v, left: null, right: null };
            render(null, v);
            setBtns(true);
            return;
          }
          cur = cur.left;
          render(cur.value);
          await step();
        } else if (v > cur.value) {
          showPseudo(P_INSERT, 5, v + ' > ' + cur.value + ' → go right.');
          await step();
          if (!cur.right) {
            showPseudo(P_INSERT, 7, 'Right is null → insert new node here.'); render(cur.value);
            cur.right = { value: v, left: null, right: null };
            render(null, v);
            setBtns(true);
            return;
          }
          cur = cur.right;
          render(cur.value);
          await step();
        } else {
          showPseudo(P_INSERT, 6, v + ' == ' + cur.value + ' → duplicate; return.');
          setBtns(true);
          return;
        }
      }
    }
    const P_SEARCH = [
      '// Search — follow BST order',
      'if root is null: return false',
      'current = root',
      'while current ≠ null:',
      '  if value == current.value: return true',
      '  if value < current.value: current = current.left',
      '  else: current = current.right',
      'return false'
    ];
    async function search() {
      const val = document.getElementById('val').value.trim();
      if (!val) { showPseudo([], -1, 'Enter a value.'); return; }
      const v = Number(val);
      if (isNaN(v)) { showPseudo([], -1, 'Enter a number.'); return; }
      if (!root) { showPseudo(P_SEARCH, 0, 'root is null → return false.'); return; }
      setBtns(false);
      let cur = root;
      showPseudo(P_SEARCH, 1, 'root not null.'); showPseudo(P_SEARCH, 2, 'current = root.'); render(cur.value);
      await step();
      while (cur) {
        showPseudo(P_SEARCH, 3, 'while current ≠ null. At ' + cur.value); render(cur.value);
        await step();
        showPseudo(P_SEARCH, 4, 'value == current.value? ' + v + ' == ' + cur.value + ' → ' + (v === cur.value ? 'Yes!' : 'No'));
        await step();
        if (v === cur.value) { showPseudo(P_SEARCH, 4, 'Found! return true'); setBtns(true); return; }
        if (v < cur.value) {
          showPseudo(P_SEARCH, 5, v + ' < ' + cur.value + ' → current = current.left');
          if (!cur.left) { showPseudo(P_SEARCH, 6, 'current.left is null → not found. return false'); render(); setBtns(true); return; }
          cur = cur.left;
        } else {
          showPseudo(P_SEARCH, 5, v + ' > ' + cur.value + ' → current = current.right');
          if (!cur.right) { showPseudo(P_SEARCH, 6, 'current.right is null → not found. return false'); render(); setBtns(true); return; }
          cur = cur.right;
        }
        render(cur.value);
        await step();
      }
      showPseudo(P_SEARCH, 7, 'return false'); setBtns(true);
    }
    function clearTree() { root = null; render(); showPseudo([], -1, 'Tree cleared.'); }
    function buildBalancedBST(arr, lo, hi) {
      if (lo > hi) return null;
      var mid = (lo + hi) >> 1;
      var node = { value: arr[mid], left: null, right: null };
      node.left = buildBalancedBST(arr, lo, mid - 1);
      node.right = buildBalancedBST(arr, mid + 1, hi);
      return node;
    }
    function randomTree() {
      var n = Math.min(15, Math.max(1, parseInt(document.getElementById('rndSize').value, 10) || 7));
      var balanced = document.getElementById('shapeBalanced').checked;
      root = null;
      var vals = [];
      for (var i = 0; i < n; i++) vals.push(Math.floor(Math.random() * 99) + 1);
      if (balanced) {
        vals.sort(function (a, b) { return a - b; });
        root = buildBalancedBST(vals, 0, vals.length - 1);
        render();
        showPseudo([], -1, 'Balanced BST with ' + n + ' values (sorted, middle as root).');
      } else {
        vals.forEach(function (v) {
          if (!root) root = { value: v, left: null, right: null };
          else {
            var cur = root;
            while (true) {
              if (v < cur.value) { if (!cur.left) { cur.left = { value: v, left: null, right: null }; break; } cur = cur.left; }
              else if (v > cur.value) { if (!cur.right) { cur.right = { value: v, left: null, right: null }; break; } cur = cur.right; }
              else break;
            }
          }
        });
        render();
        showPseudo([], -1, 'Unbalanced BST with ' + n + ' values (random insert order).');
      }
    }
    render();
  </script>
</body>
</html>
